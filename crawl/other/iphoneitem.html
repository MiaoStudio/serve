<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style media="screen">
  /*@import url("https://fonts.googleapis.com/css?family=Roboto:300");*/
html {
background-color: black;
}

@media only screen and (min-device-width: 376px) {
html {
  background-color: #F4F5F7;
}
}
#container {
font-family: 'Roboto', sans-serif;
color: #AA2331;
background-color: black;
height: 100%;
}

#list {
position: relative;
height: 100%;
}

#newItemPerspective {
-webkit-perspective: 500px;
        perspective: 500px;
-webkit-perspective-origin: center bottom;
        perspective-origin: center bottom;
position: relative;
}

#newItem {
-webkit-transform-origin: center bottom;
        transform-origin: center bottom;
-webkit-transform-style: preserve-3d;
        transform-style: preserve-3d;
position: absolute;
width: 100%;
bottom: 0;
}

.item {
cursor: default;
position: relative;
-webkit-transition: background-color 0.5s, opacity 0.5s;
transition: background-color 0.5s, opacity 0.5s;
}

.draggedItem {
z-index: 9000;
box-shadow: 0px 0px 20px -5px rgba(0, 0, 0, 0.5);
width: 110%;
height: 110%;
margin-top: -3px;
margin-left: -5%;
}
.draggedItem .itemTitle {
font-size: 1.1em;
padding: 18.7px;
}

.itemTitle {
padding: 17px;
color: white;
-webkit-user-select: none;
   -moz-user-select: none;
    -ms-user-select: none;
        user-select: none;
}

#fakeInput {
position: absolute;
background-color: transparent;
color: transparent;
border: none;
padding: 0;
margin: 17px;
}

.itemInput {
width: 100%;
background-color: transparent;
font-family: 'Roboto', sans-serif;
color: white;
border: none;
padding: 0;
}

#fakeInput:focus, .itemInput:focus {
outline: none;
}

body {
margin: 0;
}

/*
.html,
.body,
#phone,
#phone-face,
#screen,
#content {
height: 100%;
}
*/
@media only screen and (min-device-width: 376px) {
#phone {
  position: relative;
  width: 412px;
  height: 852px;
  border-radius: 67px;
  margin: 30px auto;
}

#phone-face {
  width: 400px;
  height: 840px;
  margin: 5px auto;
  border-radius: 61px;
}

#sensor {
  width: 11px;
  height: 11px;
  border-radius: 5px;
  margin: 15px auto 0 auto;
}

#camera-and-speaker {
  width: 110px;
  margin-top: 13px;
  margin-left: 122px;
  font-size: 0;
}

#camera {
  display: inline-block;
  vertical-align: middle;
  width: 18px;
  height: 18px;
  border-radius: 18px;
}

#speaker {
  display: inline-block;
  vertical-align: middle;
  width: 66px;
  height: 6px;
  border-radius: 3px;
  margin-left: 26px;
}

#screen {
  background-color: white;
  width: 375px;
  height: 667px;
  margin: 30px auto 0 auto;
  overflow: hidden;
}

#content {
  box-sizing: border-box;
  width: 100%;
  height: 100%;
  -webkit-transform-origin: top left;
          transform-origin: top left;
  -webkit-transform: scale(1, 1);
          transform: scale(1, 1);
  -webkit-font-smoothing: antialised;
  -moz-osx-font-smoothing: grayscale;
}

#home-button {
  width: 59px;
  height: 59px;
  margin: 17px auto 0 auto;
  border-radius: 59px;
}

#mute-button {
  position: absolute;
  left: -6px;
  top: 111px;
  height: 33px;
  width: 6px;
}

#volume-up-button {
  position: absolute;
  left: -5px;
  top: 181px;
  height: 65px;
  width: 5px;
  border-radius: 5px 0 0 5px;
}

#volume-down-button {
  position: absolute;
  left: -5px;
  top: 266px;
  height: 65px;
  width: 5px;
  border-radius: 5px 0 0 5px;
}

#power-button {
  position: absolute;
  right: -5px;
  top: 179px;
  height: 65px;
  width: 5px;
  border-radius: 0 5px 5px 0;
}

.gray-border {
  border: 1px solid gray;
  box-sizing: border-box;
}
}

  </style>
</head>
<body>

<div class="gray-border" id="phone">
  <div class="gray-border" id="phone-face">
    <div class="gray-border" id="sensor"></div>
    <div id="camera-and-speaker">
      <div class="gray-border" id="camera"></div>
      <div class="gray-border" id="speaker"></div>
    </div>
    <div class="gray-border" id="screen">
      <div id="content"><div data-reactroot="" id="container"><div id="list" style="top: 0px;"><div id="newItemPerspective" style="height: 0px;"><div id="newItem" style="transform: rotateX(90deg);"><!-- react-text: 54 --><!-- /react-text --><div class="item" style="left: 0px; height: auto; min-height: 52px; opacity: 1;"><div class="itemTitle"></div></div></div></div></div></div></div>
    </div>
    <div class="gray-border" id="home-button"></div>
  </div>
  <div class="gray-border" id="mute-button"></div>
  <div class="gray-border" id="volume-up-button"></div>
  <div class="gray-border" id="volume-down-button"></div>
  <div class="gray-border" id="power-button"></div>
</div>
<script src="https://cdn.bootcss.com/react/15.5.4/react.min.js"></script>
<script src="https://cdn.bootcss.com/react/15.5.4/react-dom.min.js"></script>
<script src="https://cdn.bootcss.com/rxjs/2.3.22/rx.all.min.js"></script>
<script src="https://cdn.bootcss.com/redux/3.6.0/redux.min.js"></script>
<script src="https://cdn.bootcss.com/react-redux/5.0.5/react-redux.min.js"></script>
<script>"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* Import { createStore, combineReducers } from 'redux' */
var _Redux = Redux;
var createStore = _Redux.createStore;
var combineReducers = _Redux.combineReducers;

/* Import { connect, Provider } from 'react-redux' */

var _ReactRedux = ReactRedux;
var connect = _ReactRedux.connect;
var Provider = _ReactRedux.Provider;

/*********
* RxJS utility
**********/

var util = function () {
  /* Using RxJS for creating new aggregated events for complex user interactions,
   * like vertical / horizontal swipes, short clicks and hold than drag events
   * on a single DOM item based on the basic mouse and touch events.
   */
  function getDragObservables(domItem) {
    var preventDefault = function preventDefault(event) {
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") event.preventDefault();
    };
    var mouseEventToCoordinate = function mouseEventToCoordinate(mouseEvent) {
      preventDefault(mouseEvent);
      return { x: mouseEvent.clientX, y: mouseEvent.clientY };
    };
    var touchEventToCoordinate = function touchEventToCoordinate(touchEvent) {
      preventDefault(touchEvent);
      return { x: touchEvent.changedTouches[0].clientX, y: touchEvent.changedTouches[0].clientY };
    };

    var mouseDowns = Rx.Observable.fromEvent(domItem, "mousedown").map(mouseEventToCoordinate).do(function () {
      return console.log('mouse down');
    });
    var mouseMoves = Rx.Observable.fromEvent(window, "mousemove").map(mouseEventToCoordinate).do(function () {
      return console.log('mouse move');
    });
    var mouseUps = Rx.Observable.fromEvent(window, "mouseup").map(mouseEventToCoordinate).do(function () {
      return console.log('mouse up');
    });

    var touchStarts = Rx.Observable.fromEvent(domItem, "touchstart").map(touchEventToCoordinate).do(function () {
      return console.log('touch start');
    });
    var touchMoves = Rx.Observable.fromEvent(domItem, "touchmove").map(touchEventToCoordinate).do(function () {
      return console.log('touch move');
    });
    var touchEnds = Rx.Observable.fromEvent(window, "touchend").map(touchEventToCoordinate).do(function () {
      return console.log('touch end');
    });
    var touchCancels = Rx.Observable.fromEvent(window, "touchcancel").map(touchEventToCoordinate).do(function () {
      return console.log('touch cancel');
    });

    var _starts = mouseDowns.merge(touchStarts);
    var _moves = mouseMoves.merge(touchMoves);
    var _ends = mouseUps.merge(touchEnds).merge(touchCancels);

    var HOLDING_PERIOD = 600; // milliseconds

    // Clicks: Take the start-end pairs only if no more than 3 move events happen in between, and the end event is within the holding period
    var clicks = _starts.concatMap(function (dragStartEvent) {
      return _ends.first().takeUntil(_moves.elementAt(3)).takeUntil(Rx.Observable.timer(HOLDING_PERIOD)).do(function () {
        return console.log('click');
      }).catch(function (err) {
        return Rx.Observable.empty();
      });
    });

    // Holds: Take those starts where no end event and no more than 3 move event occurs during the holding period
    var holds = _starts.concatMap(function (dragStartEvent) {
      return Rx.Observable.timer(HOLDING_PERIOD).takeUntil(_moves.elementAt(3)).takeUntil(_ends).map(function () {
        return { x: dragStartEvent.x, y: dragStartEvent.y };
      }).do(function () {
        return console.log('hold');
      }).catch(function (err) {
        return Rx.Observable.empty();
      });
    });

    // Move starts with direction: Pair the move start events with the 3rd subsequent move event,
    // but only if it happens during the holdign period and no end event happens in between
    var moveStartsWithDirection = _starts.concatMap(function (dragStartEvent) {
      return _moves.takeUntil(_ends).takeUntil(Rx.Observable.timer(HOLDING_PERIOD)).elementAt(3).catch(function (err) {
        return Rx.Observable.empty();
      }).map(function (dragEvent) {
        var intialDeltaX = dragEvent.x - dragStartEvent.x;
        var initialDeltaY = dragEvent.y - dragStartEvent.y;
        return { x: dragStartEvent.x, y: dragStartEvent.y, intialDeltaX: intialDeltaX, initialDeltaY: initialDeltaY };
      });
    });

    // Vertical move starts: Keep only those move start events where the 3rd subsequent move event is rather vertical than horizontal
    var verticalMoveStarts = moveStartsWithDirection.filter(function (dragStartEvent) {
      return Math.abs(dragStartEvent.intialDeltaX) < Math.abs(dragStartEvent.initialDeltaY);
    }).do(function () {
      return console.log('vertical move starts');
    });

    // Horizontal move starts: Keep only those move start events where the 3rd subsequent move event is rather horizontal than vertical
    var horizontalMoveStarts = moveStartsWithDirection.filter(function (dragStartEvent) {
      return Math.abs(dragStartEvent.intialDeltaX) >= Math.abs(dragStartEvent.initialDeltaY);
    }).do(function () {
      return console.log('horizontal move starts');
    });

    // Take the moves until an end occurs
    var movesUntilEnds = function movesUntilEnds(dragStartEvent) {
      return _moves.takeUntil(_ends).map(function (dragEvent) {
        var x = dragEvent.x - dragStartEvent.x;
        var y = dragEvent.y - dragStartEvent.y;
        return { x: x, y: y };
      });
    };

    var verticalMoves = verticalMoveStarts.concatMap(movesUntilEnds).do(function () {
      return console.log('vertical move');
    });
    var horizontalMoves = horizontalMoveStarts.concatMap(movesUntilEnds).do(function () {
      return console.log('horizontal move');
    });
    var dragMoves = holds.concatMap(movesUntilEnds).do(function () {
      return console.log('dragging');
    });

    var lastMovesAtEnds = function lastMovesAtEnds(dragStartEvent) {
      return _ends.first().map(function (dragEndEvent) {
        console.log(dragStartEvent, dragEndEvent);
        var x = dragEndEvent.x - dragStartEvent.x;
        var y = dragEndEvent.y - dragStartEvent.y;
        return { x: x, y: y };
      });
    };

    var ends = _starts.concatMap(lastMovesAtEnds);
    var verticalMoveEnds = verticalMoveStarts.concatMap(lastMovesAtEnds).do(function () {
      return console.log('vertical move end');
    });
    var horizontalMoveEnds = horizontalMoveStarts.concatMap(lastMovesAtEnds).do(function () {
      return console.log('horizontal move end');
    });
    var dragMoveEnds = holds.concatMap(lastMovesAtEnds).do(function () {
      return console.log('dragging end');
    });

    return {
      clicks: clicks, holds: holds,
      verticalMoveStarts: verticalMoveStarts, horizontalMoveStarts: horizontalMoveStarts,
      verticalMoves: verticalMoves, horizontalMoves: horizontalMoves,
      verticalMoveEnds: verticalMoveEnds, horizontalMoveEnds: horizontalMoveEnds,
      dragMoves: dragMoves, dragMoveEnds: dragMoveEnds
    };
  }

  return { getDragObservables: getDragObservables };
}();

/*********
* REACT: List
**********/
var List = function () {
  var UnconnectedList = function (_React$Component) {
    _inherits(UnconnectedList, _React$Component);

    function UnconnectedList(_ref) {
      var id = _ref.id;
      var title = _ref.title;
      var color = _ref.color;
      var edited = _ref.edited;

      _classCallCheck(this, UnconnectedList);

      var _this = _possibleConstructorReturn(this, _React$Component.call(this, { id: id, title: title, color: color, edited: edited }));

      _this.state = {
        y: 0,
        newItemTitle: 'Pull to Create Item',
        fakeInputVisibile: false
      };

      _this.newItemId = 0;
      _this.itemHeight = 52;

      _this.slideBack = _this.slideBack.bind(_this);
      _this.slideToEdit = _this.slideToEdit.bind(_this);
      _this.onFakeInputBlur = _this.onFakeInputBlur.bind(_this);
      return _this;
    }

    UnconnectedList.prototype.slideBack = function slideBack() {
      var _this2 = this;

      var lastTime = null;

      var slideBackAnimation = function (time) {
        var y = null;
        if (lastTime !== null) {
          var delta = (time - lastTime) * 0.3;
          if (_this2.state.y > 0) {
            y = Math.max(0, _this2.state.y - delta);
          } else {
            y = Math.min(0, _this2.state.y + delta);
          }
          _this2.setState({ y: y });
        }
        lastTime = time;
        if (y !== 0) requestAnimationFrame(slideBackAnimation);
      }.bind(this);

      requestAnimationFrame(slideBackAnimation);
    };

    UnconnectedList.prototype.slideToEdit = function slideToEdit() {
      var _this3 = this;

      var lastTime = null;

      var slideToEditAnimation = function (resolve, reject, time) {
        var y = _this3.state.y;
        if (lastTime !== null) {
          var delta = (time - lastTime) * 0.7;
          y = Math.max(_this3.itemHeight, _this3.state.y - delta);
          _this3.setState({ y: y });
        }
        console.log(y);
        lastTime = time;
        if (y > _this3.itemHeight) {
          requestAnimationFrame(function (time) {
            slideToEditAnimation(resolve, reject, time);
          });
        } else {
          _this3.setState({ y: 0 });
          resolve();
        }
      }.bind(this);

      return new Promise(function (resolve, reject) {
        requestAnimationFrame(function (time) {
          slideToEditAnimation(resolve, reject, time);
        });
      });
    };

    UnconnectedList.prototype.onFakeInputBlur = function onFakeInputBlur() {
      this.setState({ fakeInputVisibile: false });
    };

    UnconnectedList.prototype.render = function render() {
      var _this4 = this;

      var newItemRotate = Math.max(0, Math.min(90, Math.asin(-Math.min(this.itemHeight, this.state.y) / this.itemHeight) / Math.PI * 180 + 90));
      var fakeInput = this.state.fakeInputVisibile ? React.createElement("input", {
        /* The fake input's role is to force the keyboard to show up on mobile devices.
        * On mobile devices the focus can only be set to an input field from code if:
        * - the focus method is called as a direct result of a user interaction or
        * - the keyboard is already shown.
        * In this case the user interaction happens to be in this component therefore,
        * the focus can be set here, but the item desired focus is two components deep,
        * so the focus is set for the fake input to force the keyboard to show up,
        * then reset by the real input field once the keyboard is already there.
        */
        id: "fakeInput", type: "text",
        ref: function ref(fakeInput) {
          _this4.fakeInput = fakeInput;
        },
        onBlur: this.onFakeInputBlur }) : '';
      return React.createElement(
        "div",
        { id: "container" },
        React.createElement(
          "div",
          {
            id: "list",
            style: { top: Math.min(0, this.state.y) },
            ref: function ref(draggable) {
              _this4.draggable = draggable;
            } },
          React.createElement(
            "div",
            { id: "newItemPerspective", style: { height: Math.max(0, this.state.y) } },
            React.createElement(
              "div",
              { id: "newItem", style: { transform: "rotateX(" + newItemRotate + "deg)" } },
              fakeInput,
              React.createElement(Item, {
                key: this.newItemId, id: this.newItemId,
                title: this.state.newItemTitle, color: this.props.colors[0] })
            )
          ),
          this.props.items.map(function (item, index) {
            return React.createElement(Item, {
              key: item.id, id: item.id,
              title: item.title, color: _this4.props.colors[index],
              edit_mode: _this4.props.edit_mode,
              edited: _this4.props.edited_item === item.id || _this4.props.edited_item === 'FIRST' && index === 0 });
          })
        )
      );
    };

    UnconnectedList.prototype.componentDidMount = function componentDidMount() {
      var _this5 = this;

      var observables = util.getDragObservables(this.draggable);

      observables.verticalMoves.forEach(function (coordinate) {
        if (_this5.props.edit_mode === false) {
          if (coordinate.y > _this5.itemHeight) {
            _this5.setState({
              newItemTitle: 'Release to Create Item',
              y: coordinate.y
            });
          } else {
            _this5.setState({
              newItemTitle: 'Pull to Create Item',
              y: coordinate.y
            });
          }
        }
      });

      observables.verticalMoveEnds.forEach(function (coordinate) {
        if (_this5.props.edit_mode === false) {
          if (coordinate.y > _this5.itemHeight) {
            _this5.setState({
              newItemTitle: '',
              fakeInputVisibile: true
            });
            _this5.fakeInput.focus();
            _this5.slideToEdit().then(_this5.props.appendTop);
          } else {
            _this5.slideBack();
          }
        }
      });
    };

    return UnconnectedList;
  }(React.Component);

  var listMapStateToProps = function listMapStateToProps(state, ownProps) {
    return {
      items: state.items,
      colors: state.colors,
      edit_mode: state.edit.edit_mode,
      edited_item: state.edit.edited_item
    };
  };

  var listMapDispatchToProps = function listMapDispatchToProps(dispatch, ownProps) {
    return {
      appendTop: function appendTop() {
        dispatch({ type: 'APPEND_TOP' });
      }
    };
  };
  return connect(listMapStateToProps, listMapDispatchToProps)(UnconnectedList);
}();

/*********
* REACT: Item
**********/
var Item = function () {
  var UnconnectedItem = function (_React$Component2) {
    _inherits(UnconnectedItem, _React$Component2);

    function UnconnectedItem(_ref2) {
      var id = _ref2.id;
      var title = _ref2.title;
      var color = _ref2.color;
      var edit_mode = _ref2.edit_mode;
      var edited = _ref2.edited;

      _classCallCheck(this, UnconnectedItem);

      var _this6 = _possibleConstructorReturn(this, _React$Component2.call(this, { id: id, title: title, color: color, edit_mode: edit_mode, edited: edited }));

      _this6.state = {
        x: 0,
        height: 'auto',
        dragging: false,
        shrinking: false
      };

      _this6.itemHeight = 52;
      _this6.relativePosition = 0; // Relative position of the item during rearrange
      _this6.terminate = false;

      _this6.slideBack = _this6.slideBack.bind(_this6);
      _this6.slideDone = _this6.slideDone.bind(_this6);
      _this6.slideDelete = _this6.slideDelete.bind(_this6);
      _this6.shrink = _this6.shrink.bind(_this6);
      _this6.done = _this6.done.bind(_this6);
      _this6.delete = _this6.delete.bind(_this6);
      return _this6;
    }

    UnconnectedItem.prototype.slideBack = function slideBack() {
      var _this7 = this;

      var lastTime = null;

      var slideBackAnimation = function (time) {
        var x = null;
        if (lastTime !== null) {
          var delta = (time - lastTime) * 0.3;
          if (_this7.state.x > 0) {
            x = Math.max(0, _this7.state.x - delta);
          } else {
            x = Math.min(0, _this7.state.x + delta);
          }
          _this7.setState({ x: x });
        }
        lastTime = time;
        if (x !== 0) requestAnimationFrame(slideBackAnimation);
      }.bind(this);

      requestAnimationFrame(slideBackAnimation);
    };

    UnconnectedItem.prototype.slideDone = function slideDone() {
      var _this8 = this;

      var lastTime = null;

      var slideDoneAnimation = function (resolve, reject, time) {
        var x = null;
        if (lastTime !== null) {
          var delta = (time - lastTime) * 1;
          x = _this8.state.x + delta;
          _this8.setState({ x: x });
        }
        lastTime = time;
        if (x < 375) {
          requestAnimationFrame(function (time) {
            slideDoneAnimation(resolve, reject, time);
          });
        } else {
          resolve();
        }
      }.bind(this);

      return new Promise(function (resolve, reject) {
        requestAnimationFrame(function (time) {
          slideDoneAnimation(resolve, reject, time);
        });
      });
    };

    UnconnectedItem.prototype.slideDelete = function slideDelete() {
      var _this9 = this;

      var lastTime = null;

      var slideDeleteAnimation = function (resolve, reject, time) {
        var x = null;
        if (lastTime !== null) {
          var delta = (time - lastTime) * 1;
          x = _this9.state.x - delta;
          _this9.setState({ x: x });
        }
        lastTime = time;
        if (x > -375) {
          requestAnimationFrame(function (time) {
            slideDeleteAnimation(resolve, reject, time);
          });
        } else {
          resolve();
        }
      }.bind(this);

      return new Promise(function (resolve, reject) {
        requestAnimationFrame(function (time) {
          slideDeleteAnimation(resolve, reject, time);
        });
      });
    };

    UnconnectedItem.prototype.shrink = function shrink() {
      var _this10 = this;

      this.setState({
        shrinking: true,
        height: parseInt(getComputedStyle(this.draggable).getPropertyValue('height'))
      });

      var lastTime = null;

      var shrinkAnimation = function (resolve, reject, time) {
        var height = _this10.state.height;
        if (lastTime !== null) {
          var delta = (time - lastTime) * 0.5;
          height = Math.max(0, _this10.state.height - delta);
          _this10.setState({ height: height });
        }
        lastTime = time;
        if (height > 0) {
          requestAnimationFrame(function (time) {
            shrinkAnimation(resolve, reject, time);
          });
        } else {
          resolve();
        }
      }.bind(this);

      return new Promise(function (resolve, reject) {
        requestAnimationFrame(function (time) {
          shrinkAnimation(resolve, reject, time);
        });
      });
    };

    UnconnectedItem.prototype.done = function done() {
      this.props.done(this.props.id);
    };

    UnconnectedItem.prototype.delete = function _delete() {
      this.props.delete(this.props.id);
    };

    UnconnectedItem.prototype.render = function render() {
      var _this11 = this;

      var itemContent = this.props.edited !== true ? this.props.title : React.createElement(ItemInput, { id: this.props.id, title: this.props.title });
      return React.createElement(
        "div",
        { className: "item" + (this.state.dragging === true ? " draggedItem" : ""),
          style: {
            backgroundColor: this.props.color,
            left: this.state.x,
            top: this.state.y,
            height: this.state.height,
            minHeight: this.state.shrinking ? 0 : this.itemHeight,
            opacity: this.props.edit_mode === true && this.props.edited === false ? 0.3 : 1
          },
          ref: function ref(draggable) {
            _this11.draggable = draggable;
          } },
        React.createElement(
          "div",
          { className: "itemTitle" },
          itemContent
        )
      );
    };

    UnconnectedItem.prototype.componentDidMount = function componentDidMount() {
      var _this12 = this;

      var observables = util.getDragObservables(this.draggable);

      observables.holds.forEach(function () {
        _this12.relativePosition = 0;
        _this12.setState({ dragging: true });
      });

      observables.dragMoves.forEach(function (coordinate) {
        if (_this12.props.edit_mode === false) {

          var y = coordinate.y - _this12.relativePosition * _this12.itemHeight;
          if (y > _this12.itemHeight) {
            _this12.relativePosition++;
            _this12.props.moveDown(_this12.props.id);
          } else if (y < -_this12.itemHeight) {
            _this12.relativePosition--;
            _this12.props.moveUp(_this12.props.id);
          }
          y = coordinate.y - _this12.relativePosition * _this12.itemHeight;
          _this12.setState({ x: coordinate.x / 2, y: y });
        }
      });

      observables.dragMoveEnds.forEach(function (coordinate) {
        _this12.setState({
          x: 0,
          y: 0,
          dragging: false
        });
      });

      observables.clicks.forEach(function () {
        if (_this12.props.edit_mode === false) {
          _this12.props.editModeOn(_this12.props.id);
        } else if (_this12.props.edited === false) {
          _this12.props.editModeOff();
        }
      });

      observables.horizontalMoves.forEach(function (coordinate) {
        if (_this12.props.edit_mode === false) {
          _this12.setState({ x: coordinate.x });
        }
      });

      observables.horizontalMoveEnds.forEach(function (coordinate) {
        if (_this12.props.edit_mode === false) {
          if (coordinate.x > 40) {
            _this12.slideDone().then(_this12.shrink).then(_this12.done);
          } else if (coordinate.x < -40) {
            _this12.slideDelete().then(_this12.shrink).then(_this12.delete);
          } else {
            _this12.slideBack();
          }
        }
      });
    };

    UnconnectedItem.prototype.componentDidUpdate = function componentDidUpdate() {
      if (this.terminate === false && this.props.edit_mode === false && this.props.title === '') {
        this.terminate = true;
        this.slideDelete().then(this.shrink).then(this.delete);
      }
    };

    return UnconnectedItem;
  }(React.Component);

  var itemMapDispatchToProps = function itemMapDispatchToProps(dispatch, ownProps) {
    return {
      editModeOn: function editModeOn(id) {
        dispatch({ type: 'EDIT_MODE_ON', id: id });
      },
      editModeOff: function editModeOff() {
        dispatch({ type: 'EDIT_MODE_OFF' });
      },
      done: function done(id) {
        dispatch({ type: 'DONE', id: id });
      },
      delete: function _delete(id) {
        dispatch({ type: 'DELETE', id: id });
      },
      moveUp: function moveUp(id) {
        dispatch({ type: 'MOVE_UP', id: id });
      },
      moveDown: function moveDown(id) {
        dispatch({ type: 'MOVE_DOWN', id: id });
      }
    };
  };
  return connect(null, itemMapDispatchToProps)(UnconnectedItem);
}();

/*********
* REACT: Item Input
**********/
var ItemInput = function () {
  var UnconnectedItemInput = function (_React$Component3) {
    _inherits(UnconnectedItemInput, _React$Component3);

    function UnconnectedItemInput(_ref3) {
      var id = _ref3.id;
      var title = _ref3.title;

      _classCallCheck(this, UnconnectedItemInput);

      var _this13 = _possibleConstructorReturn(this, _React$Component3.call(this, { id: id, title: title }));

      _this13.keyPressed = _this13.keyPressed.bind(_this13);
      _this13.update = _this13.update.bind(_this13);
      _this13.blur = _this13.blur.bind(_this13);
      return _this13;
    }

    UnconnectedItemInput.prototype.update = function update(event) {
      this.props.update(this.props.id, event.target.value);
    };

    UnconnectedItemInput.prototype.keyPressed = function keyPressed(event) {
      if (event.keyCode == 13) {
        // Enter / Return key
        this.props.editModeOff();
      }
    };

    UnconnectedItemInput.prototype.blur = function blur(event) {
      this.props.editModeOff();
    };

    UnconnectedItemInput.prototype.render = function render() {
      var _this14 = this;

      return React.createElement("input", { type: "text", className: "itemInput",
        value: this.props.title,
        onChange: this.update, onKeyDown: this.keyPressed, onBlur: this.blur,
        ref: function ref(input) {
          _this14.input = input;
        } });
    };

    UnconnectedItemInput.prototype.componentDidMount = function componentDidMount() {
      this.input.focus();
      // Unrelated curiosity: How to trigger a touch event from code: https://w3c.github.io/touch-events/#touchevent-interface
    };

    return UnconnectedItemInput;
  }(React.Component);

  var itemInputMapDispatchToProps = function itemInputMapDispatchToProps(dispatch, ownProps) {
    return {
      editModeOff: function editModeOff() {
        dispatch({ type: 'EDIT_MODE_OFF' });
      },
      update: function update(id, title) {
        dispatch({ type: 'UPDATE', id: id, title: title });
      }
    };
  };
  return connect(null, itemInputMapDispatchToProps)(UnconnectedItemInput);
}();

/*********
* REDUX: Store
**********/
var store = function () {
  var initialState = {
    items: [{ id: 1, title: 'Swipe to the right to complete task' }, { id: 2, title: 'Swipe to the left to delete item' }, { id: 3, title: 'Pull down to create item' }, { id: 4, title: 'Tap to edit description' }, { id: 5, title: 'Hold and drag to rearrange' }, { id: 6, title: 'Go to the gym' }, { id: 7, title: 'Buy groceries' }],
    colors: ['#D90015', '#DC1C17', '#DE3A17', '#E25819', '#E4751B', '#E7921B', '#E9AF1D'],
    edit: {
      edit_mode: false,
      edited_item: null
    }
  };

  var itemReducer = function itemReducer() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? initialState.items : arguments[0];
    var action = arguments[1];

    switch (action.type) {
      case 'APPEND_TOP':
        {
          console.log('APPEND TOP');
          var newId = new Date().getTime(); // No, the ID does not have to be the current time, but the current time is sort of unique
          return [{ id: newId, title: '' }].concat(state);
        }
      case 'DONE':
        {
          return state.filter(function (item) {
            return item.id !== action.id;
          });
        }
      case 'DELETE':
        {
          return state.filter(function (item) {
            return item.id !== action.id;
          });
        }
      case 'MOVE_DOWN':
        {
          console.log('MOVE DOWN', action.id);
          var index = state.findIndex(function (item) {
            return item.id === action.id;
          });
          if (index === state.length - 1) return state;
          return [].concat(state.slice(0, index), [state[index + 1], state[index]], state.slice(index + 2));
        }
      case 'MOVE_UP':
        {
          console.log('MOVE UP', action.id);
          var index = state.findIndex(function (item) {
            return item.id === action.id;
          });
          if (index === 0) return state;
          return [].concat(state.slice(0, index - 1), [state[index], state[index - 1]], state.slice(index + 1));
        }
      case 'UPDATE':
        {
          return state.map(function (item) {
            if (item.id !== action.id) {
              return item; // This isn't the item we care about - keep it as-is
            }
            return { // Otherwise, this is the one we want - return an updated value
              id: action.id,
              title: action.title
            };
          });
        }
      default:
        return state;
    }
  };

  var colorReducer = function colorReducer() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? initialState.colors : arguments[0];
    var action = arguments[1];

    //https://gist.github.com/rosszurowski/67f04465c424a9bc0dae
    var lerpColor = function lerpColor(a, b, amount) {
      var ah = parseInt(a.replace(/#/g, ''), 16),
          ar = ah >> 16,
          ag = ah >> 8 & 0xff,
          ab = ah & 0xff,
          bh = parseInt(b.replace(/#/g, ''), 16),
          br = bh >> 16,
          bg = bh >> 8 & 0xff,
          bb = bh & 0xff,
          rr = ar + amount * (br - ar),
          rg = ag + amount * (bg - ag),
          rb = ab + amount * (bb - ab);
      return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);
    };

    // Generates a range of interpolated colors from color a to b
    var colorRange = function colorRange(length) {
      var a = arguments.length <= 1 || arguments[1] === undefined ? '#D90015' : arguments[1];
      var b = arguments.length <= 2 || arguments[2] === undefined ? '#E9AF1D' : arguments[2];
      return Array.from({ length: length }, function (value, key) {
        return lerpColor(a, b, 1 / length * key);
      });
    };

    switch (action.type) {
      case 'APPEND_TOP':
        {
          return colorRange(state.length + 1);
        }
      case 'DONE':
      case 'DELETE':
        {
          return colorRange(state.length - 1);
        }
      default:
        return state;
    }
  };

  var editReducer = function editReducer() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? initialState.edit : arguments[0];
    var action = arguments[1];

    switch (action.type) {
      case 'APPEND_TOP':
        {
          return {
            edit_mode: true,
            edited_item: 'FIRST'
          };
        }
      case 'EDIT_MODE_ON':
        {
          console.log('EDIT MODE ON', action.id);
          return {
            edit_mode: true,
            edited_item: action.id
          };
        }
      case 'EDIT_MODE_OFF':
        {
          console.log('EDIT MODE OFF');
          return {
            edit_mode: false,
            edited_item: null
          };
        }
      default:
        return state;
    }
  };

  var mainReducer = combineReducers({
    items: itemReducer,
    colors: colorReducer,
    edit: editReducer
  });

  return createStore(mainReducer);
}();

/*********
* REACT DOM
**********/
ReactDOM.render(React.createElement(
  Provider,
  { store: store },
  React.createElement(List, null)
), document.getElementById('content'));
//# sourceURL=pen.js
</script>
</body>
</html>
